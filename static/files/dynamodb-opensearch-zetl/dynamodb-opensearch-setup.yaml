AWSTemplateFormatVersion: '2010-09-09'
Description: A CloudFormation template that creates an OpenSearch Service domain.

Parameters:
  OpenSearchClusterName:
    Type: String
    Description: The name for the OpenSearch cluster.
    Default: "workshop"
    AllowedPattern: '[a-z][a-z0-9\-]+'
    MaxLength: 21
    ConstraintDescription: The cluster name must start with a lowercase letter and can only contain lowercase letters, numbers, and dashes.

Resources:
  OpenSearchSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: This is a Secrets Manager secret for a the DynamoDB zero ETL to OpenSearch lab
      GenerateSecretString:
        SecretStringTemplate: '{"username": "master-user"}'
        GenerateStringKey: password
        PasswordLength: 16
        ExcludeCharacters: "\"'@/\\"

  SecretPlaintextLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: !Sub lambda.${AWS::URLSuffix}
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AwsSecretsManager
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: 
                  - !Ref OpenSearchSecret

  SecretPlaintextLambda:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: Warning incorrectly reported. The role associated with the Lambda function has the AWSLambdaBasicExecutionRole managed policy attached, which includes permission to write CloudWatch Logs. See https://docs.aws.amazon.com/aws-managed-policy/latest/reference/AWSLambdaBasicExecutionRole.html
          - id: W89
            reason: CloudFormation custom function does not need the scaffolding of a VPC, to do so would add unnecessary complexity
          - id: W92
            reason: CloudFormation custom function does not need reserved concurrent executions, to do so would add unnecessary complexity
    Properties:
      Description: Return the value of the secret
      Handler: index.lambda_handler
      Runtime: python3.13
      MemorySize: 128
      Timeout: 10
      Architectures:
        - arm64
      Role: !GetAtt SecretPlaintextLambdaRole.Arn
      Code:
        ZipFile: |
          import boto3
          import json
          import cfnresponse
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def is_valid_json(json_string):
              logger.debug(f'Calling is_valid_jason:{json_string}')
              try:
                  json.loads(json_string)
                  logger.info('Secret is in json format')
                  return True
              except json.JSONDecodeError:
                  logger.info('Secret is in string format')
                  return False

          def lambda_handler(event, context):
              logger.debug(f'event: {event}')
              logger.debug(f'context: {context}')
              try:
                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='No action to take')
                  else:
                      resource_properties = event['ResourceProperties']
                      secret_name = resource_properties['SecretArn']
                      secrets_mgr = boto3.client('secretsmanager')

                      logger.info('Getting secret from %s', secret_name)

                      secret = secrets_mgr.get_secret_value(SecretId = secret_name)
                      logger.debug(f'secret: {secret}')
                      secret_value = secret['SecretString']

                      responseData = {}
                      if is_valid_json(secret_value):
                          responseData = secret_value
                      else:
                          responseData = {'secret': secret_value}
                      logger.debug(f'responseData: {responseData}')
                      logger.debug(f'type(responseData): {type(responseData)}')
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData=json.loads(responseData), reason='OK', noEcho=True)
              except Exception as e:
                  logger.error(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=str(e))

  SecretPlaintext:
    Type: Custom::SecretPlaintextLambda
    Properties:
      ServiceToken: !GetAtt SecretPlaintextLambda.Arn
      ServiceTimeout: 15
      SecretArn: !Ref OpenSearchSecret


  ProductDetailsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: ProductDetails
      AttributeDefinitions:
        - AttributeName: ProductID
          AttributeType: S
      KeySchema:
        - AttributeName: ProductID
          KeyType: HASH
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: True
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES

  OpenSearchServiceDomain:
    Type: AWS::OpenSearchService::Domain
    Properties:
      DomainName: !Sub "ddb-os-${OpenSearchClusterName}"
      ClusterConfig:
        DedicatedMasterEnabled: false
        ZoneAwarenessEnabled: false
        InstanceCount: '1'
        InstanceType: 't3.small.search'
      DomainEndpointOptions:
        EnforceHTTPS: true
      EBSOptions:
        EBSEnabled: true
        VolumeSize: 20
        VolumeType: "gp3"
      NodeToNodeEncryptionOptions:
        Enabled: true
      EncryptionAtRestOptions:
        Enabled: true
      AccessPolicies:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: !ImportValue CodeInstanceRoleArn
            Action: 'es:*'
            Resource:
              !Join
                - ''
                - - 'arn:aws:es:'
                  - !Ref "AWS::Region"
                  - ':'
                  - !Ref "AWS::AccountId"
                  - ':domain/ddb-os-'
                  - !Ref 'OpenSearchClusterName'
                  - '/*'
          - Effect: Allow
            Principal: '*'
            Action: '*'
            Resource: '*'
      AdvancedSecurityOptions:
        Enabled: true
        InternalUserDatabaseEnabled: true
        MasterUserOptions:
          MasterUserName:
            Fn::Sub: "{{resolve:secretsmanager:${OpenSearchSecret}::username}}"
          MasterUserPassword:
            Fn::Sub: "{{resolve:secretsmanager:${OpenSearchSecret}::password}}"

  PipelineBucket:
    Type: AWS::S3::Bucket
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W35
            reason: Access logs aren't needed for this bucket
    DeletionPolicy: Delete
    Properties:
      AccessControl: Private
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

Outputs:

  VSCodeUrl:
    Description: URL to launch the VSCode IDE
    Value: !ImportValue VSCodeUrl
  VSCodePassword:
    Description: VSCode Server Password (stored in AWS Secrets Manager)
    Value: !ImportValue VSCodePassword
  OSDashboardsURL:
    Description: URL to the OpenSearch Dashboards
    Value: !Sub "https://${OpenSearchServiceDomain.DomainEndpoint}/_dashboards/"
  OpenSearchPassword:
    Description: OpenSearch Password (stored in AWS Secrets Manager)
    Value: !GetAtt SecretPlaintext.password
  OSDomainEndpoint:
    Description: The endpoint of the OpenSearch domain.
    Value: !Sub "https://${OpenSearchServiceDomain.DomainEndpoint}"
    Export:
      Name: OpenSearchServiceDomain
  Region:
    Description: The region you deployed in.
    Value: !Ref "AWS::Region"
  DdbTableArn:
    Description: "ARN of the DynamoDB Table"
    Value: !GetAtt ProductDetailsTable.Arn
  Role:
    Description: "ARN of the Role used to provide access"
    Value: !ImportValue CodeInstanceRoleArn
  S3Bucket:
    Description: "Name of the S3 Bucket"
    Value: !Ref PipelineBucket